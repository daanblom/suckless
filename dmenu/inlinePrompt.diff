diff --git a/dmenu.c b/dmenu.c
index 3d82d7d..8f4f3e4 100644
--- a/dmenu.c
+++ b/dmenu.c
@@ -36,7 +36,8 @@
 #define TEXTW(X)              (drw_fontset_getwidth(drw, (X)) + lrpad)
 
 /* enums */
-enum { SchemeNorm, SchemeSel, SchemeOut, SchemeLast }; /* color schemes */
+enum { SchemeNorm, SchemeSel, SchemeOut, SchemePlaceholder, SchemeLast };
+/* SchemePlaceholder added for dimmed placeholder text */
 
 struct item {
 	char *text;
@@ -309,13 +310,21 @@ drawmenu(void)
 	drw_setscheme(drw, scheme[SchemeNorm]);
 	drw_rect(drw, 0, 0, mw, mh, 1, 1);
 
-	if (prompt && *prompt) {
-		drw_setscheme(drw, scheme[SchemeSel]);
-		x = drw_text(drw, x, 0, promptw, bh, lrpad / 2, prompt, 0);
-	}
-	/* draw input field */
-	w = (lines > 0 || !matches) ? mw - x : inputw;
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
+	/* draw input field (with placeholder if empty) */
+	w = (lines > 0 || !matches) ? mw - x : inputw;
+	if (text[0] == '\0' && prompt && *prompt) {
+		/* show prompt as placeholder inside the input field */
+		drw_setscheme(drw, scheme[SchemePlaceholder]);
+		drw_text(drw, x, 0, w, bh, lrpad / 2, prompt, 0);
+	} else {
+		drw_setscheme(drw, scheme[SchemeNorm]);
+		drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
+	}
+
+	curpos = TEXTW(text) - TEXTW(&text[cursor]);
+	if ((curpos += lrpad / 2 - 1) < w) {
+		drw_setscheme(drw, scheme[SchemeNorm]);
+		drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
+	}
